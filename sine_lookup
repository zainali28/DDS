// sine lookup value module using two symmetries
// appears like a 2048x16bit LUT even if it uses a 512x16bit internally
// 3 clock latency
module sine_lookup(input clk, input [10:0] addr, output reg [16:0] value);

wire [15:0] sine_1sym;  // sine with 1 symmetry
blockram512x16bit_2clklatency my_quarter_sine_LUT(     // the LUT contains only one quarter of the sine wave
    .rdclock(clk),
    .rdaddress(addr[9] ? ~addr[8:0] : addr[8:0]),   // first symmetry
    .q(sine_1sym)
);

// now for the second symmetry, we need to use addr[10]
// but since our blockram has 2 clock latencies on reads
// we need a two-clock delayed version of addr[10]
reg addr10_delay1; always @(posedge clk) addr10_delay1 <= addr[10];
reg addr10_delay2; always @(posedge clk) addr10_delay2 <= addr10_delay1;

wire [16:0] sine_2sym = addr10_delay2 ? {1'b0,-sine_1sym} : {1'b1,sine_1sym};  // second symmetry

// add a third latency to the module output for best performance
always @(posedge clk) value <= sine_2sym;
endmodule


module blockram512x16bit_2clklatency(
    input wire rdclock,
    input wire [8:0] rdaddress,
    output wire [15:0] q
);

    // Register the read address
    reg [8:0] rdaddress_reg;

    // Register the BRAM output
    reg [9:0] q_reg;

    always @(posedge clk) begin
        // On the first clock cycle, store the read address in rdaddress_reg
        rdaddress_reg <= rdaddress;

        // On the second clock cycle, fetch the BRAM data and store it in q_reg
        q_reg <= ram[rdaddress_reg];
    end

    // Connect the registered output q_reg to the output port q
    assign q = q_reg;
endmodule
